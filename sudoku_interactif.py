# -*- coding: utf-8 -*-
"""sudoku_interactif.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10VlZYktmAbQqhjLRQPCOZP05QxWIj_Ta
"""

# ============================================
# SUDOKU INTERACTIF POUR GOOGLE COLAB
# ============================================

import random
from IPython.display import display, HTML, clear_output
import ipywidgets as widgets

class SudokuInteractive:
    def __init__(self):
        self.grid = [[0]*9 for _ in range(9)]
        self.solution = [[0]*9 for _ in range(9)]
        self.initial_grid = [[False]*9 for _ in range(9)]
        self.selected_cell = None
        self.cells = {}
        self.output = widgets.Output()

    def is_valid(self, grid, row, col, num):
        """VÃ©rifie si 'num' est valide dans (row, col) pour une grille donnÃ©e."""
        if num in grid[row]:
            return False
        if num in [grid[i][col] for i in range(9)]:
            return False
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if grid[i][j] == num:
                    return False
        return True

    def solve(self, grid):
        """RÃ©sout la grille en utilisant le backtracking."""
        for i in range(9):
            for j in range(9):
                if grid[i][j] == 0:
                    for num in range(1, 10):
                        if self.is_valid(grid, i, j, num):
                            grid[i][j] = num
                            if self.solve(grid):
                                return True
                            grid[i][j] = 0
                    return False
        return True

    def fill_diagonal_boxes(self):
        """Remplit les boÃ®tes 3x3 de la diagonale pour le dÃ©part de la gÃ©nÃ©ration."""
        for box in range(0, 9, 3):
            nums = list(range(1, 10))
            random.shuffle(nums)
            for i in range(3):
                for j in range(3):
                    self.solution[box + i][box + j] = nums[i * 3 + j]

    def generate_puzzle(self, difficulty=40):
        """GÃ©nÃ¨re une nouvelle grille de Sudoku."""
        self.solution = [[0]*9 for _ in range(9)]
        self.initial_grid = [[False]*9 for _ in range(9)]
        self.fill_diagonal_boxes()
        self.solve(self.solution)
        self.grid = [row[:] for row in self.solution]

        cells_to_remove = difficulty
        removed = 0
        while removed < cells_to_remove:
            row = random.randint(0, 8)
            col = random.randint(0, 8)
            if self.grid[row][col] != 0:
                self.grid[row][col] = 0
                removed += 1

        for i in range(9):
            for j in range(9):
                if self.grid[i][j] != 0:
                    self.initial_grid[i][j] = True

    def check_visual_validity(self, row, col, num):
        """VÃ©rifie si le chiffre est valide dans le contexte immÃ©diat de la grille actuelle."""
        temp_grid = [r[:] for r in self.grid]
        temp_grid[row][col] = num

        count_row = sum(1 for val in temp_grid[row] if val == num)
        count_col = sum(1 for i in range(9) if temp_grid[i][col] == num)

        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        count_box = 0
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if temp_grid[i][j] == num:
                    count_box += 1

        return count_row <= 1 and count_col <= 1 and count_box <= 1

    def on_cell_click(self, row, col, button):
        if self.initial_grid[row][col]:
            return

        # DÃ©sÃ©lectionner l'ancienne cellule
        if self.selected_cell:
            old_row, old_col = self.selected_cell
            old_btn = self.cells[(old_row, old_col)]

            # Restaure la couleur en vÃ©rifiant s'il y a une erreur Ã  cette position
            current_val = self.grid[old_row][old_col]
            if current_val != 0 and not self.check_visual_validity(old_row, old_col, current_val):
                old_btn.style.button_color = '#ffdddd' # Rouge clair pour erreur
            else:
                old_btn.style.button_color = 'white'
                old_btn.style.font_weight = 'bold' # Garde le gras

        # SÃ©lectionner la nouvelle cellule
        self.selected_cell = (row, col)
        button.style.button_color = '#b3d9ff'

    def on_number_click(self, num):
        if self.selected_cell:
            row, col = self.selected_cell
            if not self.initial_grid[row][col]:
                btn = self.cells[(row, col)]

                # Mise Ã  jour de la grille et du bouton
                self.grid[row][col] = num
                btn.description = str(num) if num != 0 else ''

                # Mise Ã  jour de la couleur pour indiquer l'erreur ou rÃ©initialiser
                if num != 0 and not self.check_visual_validity(row, col, num):
                    btn.style.button_color = '#ffdddd' # Rouge clair pour erreur
                    btn.style.text_color = 'black' # Texte noir
                else:
                    btn.style.button_color = 'white' # Couleur par dÃ©faut (blanc)
                    btn.style.text_color = 'black' # Texte noir

                btn.style.font_weight = 'bold' # Chiffres en gras

                # DÃ©sÃ©lection de la cellule
                self.selected_cell = None

    def check_solution(self, button):
        """VÃ©rifie si la solution de l'utilisateur est correcte."""
        incomplete = False
        for i in range(9):
            for j in range(9):
                if self.grid[i][j] == 0:
                    incomplete = True
                    break

        with self.output:
            clear_output(wait=True)
            if incomplete:
                print("âš ï¸ Remplissez toutes les cases d'abord!")
            elif self.grid == self.solution:
                print("ðŸŽ‰ BRAVO! Vous avez rÃ©solu le Sudoku! ðŸŽ‰")
            else:
                print("âŒ Il y a des erreurs dans votre solution")

    def show_solution(self, button):
        """Affiche la solution et met Ã  jour la grille."""
        self.grid = [row[:] for row in self.solution]
        for i in range(9):
            for j in range(9):
                btn = self.cells[(i, j)]
                btn.description = str(self.grid[i][j])
                btn.style.font_weight = 'bold' # Chiffres en gras
                btn.style.text_color = 'black' # Texte noir
                if not self.initial_grid[i][j]:
                    btn.style.button_color = '#c8e6c9' # Vert clair pour la solution
                else:
                    btn.style.button_color = 'white' # Blanc pour les chiffres initiaux

        with self.output:
            clear_output(wait=True)
            print("âœ… Solution affichÃ©e!")

    def new_game(self, button, difficulty):
        """DÃ©marre une nouvelle partie."""
        self.generate_puzzle(difficulty)
        self.selected_cell = None

        for i in range(9):
            for j in range(9):
                btn = self.cells[(i, j)]
                btn.style.font_weight = 'bold' # Chiffres en gras
                btn.style.text_color = 'black' # Texte noir

                if self.grid[i][j] == 0:
                    btn.description = ''
                    btn.style.button_color = 'white'
                else:
                    btn.description = str(self.grid[i][j])
                    btn.style.button_color = 'white' # Fond blanc pour les chiffres initiaux

        with self.output:
            clear_output(wait=True)
            print(f"ðŸŽ® Nouveau jeu lancÃ©!")

    def create_interface(self):
        """Construit et affiche l'interface utilisateur avec ipywidgets."""
        # Style CSS
        style = """
        <style>
        .sudoku-title {
            text-align: center;
            color: #667eea;
            font-size: 36px;
            font-weight: bold;
            margin: 20px 0;
            font-family: Arial, sans-serif;
        }
        </style>
        """
        display(HTML(style + '<div class="sudoku-title">ðŸŽ® SUDOKU ðŸŽ®</div>'))

        # Grille de Sudoku
        grid_rows = []
        for i in range(9):
            row_buttons = []
            for j in range(9):
                btn = widgets.Button(
                    description=str(self.grid[i][j]) if self.grid[i][j] != 0 else '',
                    layout=widgets.Layout(width='50px', height='50px', border='1px solid #cccccc'), # Traits gris clairs
                    style={'font_weight': 'bold', 'font_size': '18px', 'button_color': 'white', 'text_color': 'black'} # Gras et Fond blanc
                )

                # La couleur est initialisÃ©e Ã  blanc dans le style, on rÃ©ajuste uniquement si c'est une case initiale
                # Mais ici, on s'assure juste que tout est en blanc au dÃ©part.

                btn.on_click(lambda b, r=i, c=j: self.on_cell_click(r, c, b))
                self.cells[(i, j)] = btn
                row_buttons.append(btn)

            # Pas de sÃ©parateurs intermÃ©diaires de lignes pour laisser le 'border' du bouton faire le travail
            grid_rows.append(widgets.HBox(row_buttons))

        # Ajout des sÃ©parateurs 3x3 (lignes plus Ã©paisses)
        final_grid_rows = []
        for i, row_box in enumerate(grid_rows):
            final_grid_rows.append(row_box)
            if (i + 1) % 3 == 0 and i < 8:
                # Ajoute une ligne HTML Ã©paisse pour le sÃ©parateur de boÃ®te
                final_grid_rows.append(widgets.HTML('<div style="height: 3px; background: #333; margin-top: -1px; margin-bottom: -1px;"></div>'))


        grid_box = widgets.VBox(final_grid_rows, layout=widgets.Layout(
            border='3px solid #333',
            padding='0px',
            width='459px' # Ajustement de la largeur pour la bordure 3x3
        ))

        # PavÃ© numÃ©rique (inchangÃ©)
        number_buttons = []
        for num in range(1, 10):
            btn = widgets.Button(
                description=str(num),
                layout=widgets.Layout(width='60px', height='60px'),
                style={'button_color': '#667eea', 'font_weight': 'bold'}
            )
            btn.on_click(lambda b, n=num: self.on_number_click(n))
            number_buttons.append(btn)

        clear_btn = widgets.Button(
            description='Effacer',
            layout=widgets.Layout(width='130px', height='60px'),
            style={'button_color': '#ff6b6b', 'font_weight': 'bold'}
        )
        clear_btn.on_click(lambda b: self.on_number_click(0))

        number_pad = widgets.VBox([
            widgets.HBox(number_buttons[:3]),
            widgets.HBox(number_buttons[3:6]),
            widgets.HBox(number_buttons[6:9]),
            clear_btn
        ])

        # Boutons de contrÃ´le (inchangÃ©s)
        btn_easy = widgets.Button(
            description='ðŸŸ¢ Facile',
            layout=widgets.Layout(width='140px', height='45px'),
            style={'button_color': '#4CAF50', 'font_weight': 'bold'}
        )
        btn_easy.on_click(lambda b: self.new_game(b, 30))

        btn_medium = widgets.Button(
            description='ðŸŸ¡ Moyen',
            layout=widgets.Layout(width='140px', height='45px'),
            style={'button_color': '#FFC107', 'font_weight': 'bold'}
        )
        btn_medium.on_click(lambda b: self.new_game(b, 40))

        btn_hard = widgets.Button(
            description='ðŸ”´ Difficile',
            layout=widgets.Layout(width='140px', height='45px'),
            style={'button_color': '#FF5722', 'font_weight': 'bold'}
        )
        btn_hard.on_click(lambda b: self.new_game(b, 50))

        btn_check = widgets.Button(
            description='âœ“ VÃ©rifier',
            layout=widgets.Layout(width='140px', height='45px'),
            style={'button_color': '#2196F3', 'font_weight': 'bold'}
        )
        btn_check.on_click(self.check_solution)

        btn_solve = widgets.Button(
            description='ðŸ’¡ Solution',
            layout=widgets.Layout(width='140px', height='45px'),
            style={'button_color': '#FF9800', 'font_weight': 'bold'}
        )
        btn_solve.on_click(self.show_solution)

        control_buttons = widgets.VBox([
            widgets.HBox([btn_easy, btn_medium, btn_hard]),
            widgets.HBox([btn_check, btn_solve])
        ])

        # Affichage final
        main_layout = widgets.VBox([
            widgets.HBox([grid_box, widgets.HTML('<div style="width: 30px;"></div>'), number_pad]),
            widgets.HTML('<div style="height: 20px;"></div>'),
            control_buttons,
            self.output
        ], layout=widgets.Layout(align_items='center'))

        display(main_layout)

# ============================================
# LANCER LE JEU
# ============================================
def play_sudoku():
    game = SudokuInteractive()
    game.generate_puzzle(40)
    game.create_interface()

# Afficher les instructions
print("=" * 50)
print("ðŸŽ® SUDOKU INTERACTIF POUR GOOGLE COLAB")
print("=" * 50)
print("\nðŸŽ¯ Nouveau Style de Grille AppliquÃ© :")
print("Â  Â - Chiffres en noir et gras.")
print("Â  Â - Fond blanc uni pour toutes les cases.")
print("Â  Â - SÃ©parations fines grises pour les cases individuelles.")
print("Â  Â - Lignes Ã©paisses noires pour les blocs 3x3.")
print("\nâœ¨ Bon jeu!")
print("=" * 50)

# L'appel qui lance le jeu
play_sudoku()

play_sudoku()